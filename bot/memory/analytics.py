"""
–°–µ—Ä–≤–∏—Å –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏
"""
import asyncio
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import json
from pathlib import Path

from .models import AnalyticsData

logger = logging.getLogger(__name__)


class AnalyticsService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Å–±–æ—Ä–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö –æ —Ä–∞–±–æ—Ç–µ —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏"""
    
    def __init__(self, storage_path: str = "data/analytics"):
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)
        
        # –§–∞–π–ª—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
        self.events_file = self.storage_path / "events.jsonl"
        self.daily_stats_file = self.storage_path / "daily_stats.json"
        
    async def track_event(self, session_id: str, event_type: str, 
                         event_data: Dict[str, Any] = None):
        """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç —Å–æ–±—ã—Ç–∏–µ –≤ –∞–Ω–∞–ª–∏—Ç–∏–∫–µ"""
        try:
            event = AnalyticsData(
                session_id=session_id,
                event_type=event_type,
                event_data=event_data or {}
            )
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–±—ã—Ç–∏–µ
            await self._save_event(event)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            await self._update_daily_stats(event)
            
            logger.debug(f"üìä –°–æ–±—ã—Ç–∏–µ –æ—Ç—Å–ª–µ–∂–µ–Ω–æ: {event_type} –¥–ª—è {session_id}")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è: {e}")
    
    async def get_session_events(self, session_id: str, 
                               days: int = 7) -> List[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–æ–±—ã—Ç–∏—è –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å–µ—Å—Å–∏–∏"""
        try:
            events = []
            cutoff_date = datetime.now() - timedelta(days=days)
            
            if not self.events_file.exists():
                return events
            
            with open(self.events_file, 'r', encoding='utf-8') as f:
                for line in f:
                    try:
                        event_data = json.loads(line.strip())
                        event_time = datetime.fromisoformat(event_data['timestamp'])
                        
                        if (event_data['session_id'] == session_id and 
                            event_time >= cutoff_date):
                            events.append(event_data)
                    except (json.JSONDecodeError, KeyError, ValueError):
                        continue
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏
            events.sort(key=lambda x: x['timestamp'])
            return events
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏–π –¥–ª—è {session_id}: {e}")
            return []
    
    async def get_conversion_funnel(self, days: int = 30) -> Dict[str, Any]:
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–æ—Ä–æ–Ω–∫—É –∫–æ–Ω–≤–µ—Ä—Å–∏–∏"""
        try:
            funnel_data = {
                's0_greeting': 0,
                's1_business': 0, 
                's2_goal': 0,
                's3_payment': 0,
                's4_requirements': 0,
                's5_budget': 0,
                's6_urgency': 0,
                's7_experience': 0,
                's8_action': 0,
                'qualification_cold': 0,
                'qualification_warm': 0,
                'qualification_hot': 0,
                'escalations': 0
            }
            
            cutoff_date = datetime.now() - timedelta(days=days)
            
            if not self.events_file.exists():
                return funnel_data
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏—è
            with open(self.events_file, 'r', encoding='utf-8') as f:
                for line in f:
                    try:
                        event_data = json.loads(line.strip())
                        event_time = datetime.fromisoformat(event_data['timestamp'])
                        
                        if event_time < cutoff_date:
                            continue
                        
                        event_type = event_data['event_type']
                        
                        # –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞
                        if event_type == 'state_change':
                            to_state = event_data['event_data'].get('to', '')
                            if to_state in funnel_data:
                                funnel_data[to_state] += 1
                        
                        # –°—Ç–∞—Ç—É—Å—ã –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏–∏
                        elif event_type == 'qualification_change':
                            status = event_data['event_data'].get('status', '')
                            key = f'qualification_{status}'
                            if key in funnel_data:
                                funnel_data[key] += 1
                        
                        # –≠—Å–∫–∞–ª–∞—Ü–∏–∏
                        elif event_type == 'escalation':
                            funnel_data['escalations'] += 1
                            
                    except (json.JSONDecodeError, KeyError, ValueError):
                        continue
            
            # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–Ω–≤–µ—Ä—Å–∏—é
            total_sessions = funnel_data['s0_greeting'] or 1
            conversion_rates = {}
            
            for key, value in funnel_data.items():
                if key.startswith('s') and key != 's0_greeting':
                    conversion_rates[key] = (value / total_sessions) * 100
            
            return {
                'funnel_data': funnel_data,
                'conversion_rates': conversion_rates,
                'total_sessions': total_sessions,
                'period_days': days
            }
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –≤–æ—Ä–æ–Ω–∫–∏: {e}")
            return {}
    
    async def get_daily_stats(self, days: int = 30) -> List[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∞–µ—Ç –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        try:
            if not self.daily_stats_file.exists():
                return []
            
            with open(self.daily_stats_file, 'r', encoding='utf-8') as f:
                all_stats = json.load(f)
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ
            cutoff_date = datetime.now() - timedelta(days=days)
            filtered_stats = []
            
            for date_str, stats in all_stats.items():
                try:
                    stat_date = datetime.strptime(date_str, '%Y-%m-%d')
                    if stat_date >= cutoff_date:
                        stats['date'] = date_str
                        filtered_stats.append(stats)
                except ValueError:
                    continue
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ
            filtered_stats.sort(key=lambda x: x['date'])
            return filtered_stats
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
            return []
    
    async def get_performance_metrics(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        try:
            metrics = {
                'avg_response_time': 0.0,
                'successful_extractions': 0,
                'failed_extractions': 0,
                'memory_usage': 0,
                'escalation_rate': 0.0,
                'qualification_accuracy': 0.0
            }
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è
            recent_events = await self._get_recent_events(hours=24)
            
            total_events = len(recent_events)
            if total_events == 0:
                return metrics
            
            successful_ops = 0
            failed_ops = 0
            escalations = 0
            
            for event in recent_events:
                event_type = event.get('event_type', '')
                
                if event_type == 'extraction_success':
                    successful_ops += 1
                elif event_type == 'extraction_failed':
                    failed_ops += 1
                elif event_type == 'escalation':
                    escalations += 1
            
            # –í—ã—á–∏—Å–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
            metrics['successful_extractions'] = successful_ops
            metrics['failed_extractions'] = failed_ops
            metrics['escalation_rate'] = (escalations / total_events) * 100
            
            return metrics
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: {e}")
            return {}
    
    async def generate_report(self, days: int = 7) -> Dict[str, Any]:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–≤–æ–¥–Ω—ã–π –æ—Ç—á–µ—Ç"""
        try:
            report = {
                'period': f'Last {days} days',
                'generated_at': datetime.now().isoformat(),
                'summary': {},
                'funnel_analysis': {},
                'performance_metrics': {},
                'daily_trends': [],
                'recommendations': []
            }
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            funnel = await self.get_conversion_funnel(days)
            daily_stats = await self.get_daily_stats(days)
            performance = await self.get_performance_metrics()
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç—á–µ—Ç
            report['funnel_analysis'] = funnel
            report['performance_metrics'] = performance
            report['daily_trends'] = daily_stats
            
            # –°–≤–æ–¥–∫–∞
            total_sessions = funnel.get('total_sessions', 0)
            hot_leads = funnel.get('funnel_data', {}).get('qualification_hot', 0)
            escalations = funnel.get('funnel_data', {}).get('escalations', 0)
            
            report['summary'] = {
                'total_sessions': total_sessions,
                'hot_leads': hot_leads,
                'hot_lead_rate': (hot_leads / max(total_sessions, 1)) * 100,
                'escalation_rate': (escalations / max(total_sessions, 1)) * 100
            }
            
            # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
            report['recommendations'] = await self._generate_recommendations(report)
            
            return report
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞: {e}")
            return {}
    
    async def _save_event(self, event: AnalyticsData):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ–±—ã—Ç–∏–µ –≤ —Ñ–∞–π–ª"""
        try:
            event_json = json.dumps(event.to_dict(), ensure_ascii=False)
            
            with open(self.events_file, 'a', encoding='utf-8') as f:
                f.write(event_json + '\n')
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏—è: {e}")
    
    async def _update_daily_stats(self, event: AnalyticsData):
        \"\"\"–û–±–Ω–æ–≤–ª—è–µ—Ç –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\"\"\"
        try:
            today = event.timestamp.strftime('%Y-%m-%d')
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            daily_stats = {}
            if self.daily_stats_file.exists():
                with open(self.daily_stats_file, 'r', encoding='utf-8') as f:
                    daily_stats = json.load(f)
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–µ–Ω—å –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
            if today not in daily_stats:
                daily_stats[today] = {
                    'total_events': 0,
                    'sessions': set(),
                    'event_types': {}
                }
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            day_stats = daily_stats[today]
            day_stats['total_events'] += 1
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Å—Å–∏—é (–∏—Å–ø–æ–ª—å–∑—É–µ–º set –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏)
            if isinstance(day_stats['sessions'], list):
                day_stats['sessions'] = set(day_stats['sessions'])
            day_stats['sessions'].add(event.session_id)
            
            # –°—á–∏—Ç–∞–µ–º —Ç–∏–ø—ã —Å–æ–±—ã—Ç–∏–π
            event_type = event.event_type
            if event_type not in day_stats['event_types']:
                day_stats['event_types'][event_type] = 0
            day_stats['event_types'][event_type] += 1
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º set –æ–±—Ä–∞—Ç–Ω–æ –≤ list –¥–ª—è JSON
            day_stats['sessions'] = list(day_stats['sessions'])
            day_stats['unique_sessions'] = len(day_stats['sessions'])
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º
            with open(self.daily_stats_file, 'w', encoding='utf-8') as f:
                json.dump(daily_stats, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
    
    async def _get_recent_events(self, hours: int = 24) -> List[Dict[str, Any]]:
        \"\"\"–ü–æ–ª—É—á–∞–µ—Ç —Å–æ–±—ã—Ç–∏—è –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —á–∞—Å—ã\"\"\"
        try:
            events = []
            cutoff_date = datetime.now() - timedelta(hours=hours)
            
            if not self.events_file.exists():
                return events
            
            with open(self.events_file, 'r', encoding='utf-8') as f:
                for line in f:
                    try:
                        event_data = json.loads(line.strip())
                        event_time = datetime.fromisoformat(event_data['timestamp'])
                        
                        if event_time >= cutoff_date:
                            events.append(event_data)
                    except (json.JSONDecodeError, KeyError, ValueError):
                        continue
            
            return events
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–µ–¥–∞–≤–Ω–∏—Ö —Å–æ–±—ã—Ç–∏–π: {e}")
            return []
    
    async def _generate_recommendations(self, report: Dict[str, Any]) -> List[str]:
        \"\"\"–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ—Ç—á–µ—Ç–∞\"\"\"
        recommendations = []
        
        try:
            summary = report.get('summary', {})
            funnel = report.get('funnel_analysis', {}).get('conversion_rates', {})
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–Ω–≤–µ—Ä—Å–∏—é
            hot_lead_rate = summary.get('hot_lead_rate', 0)
            escalation_rate = summary.get('escalation_rate', 0)
            
            if hot_lead_rate < 10:
                recommendations.append(
                    \"–ù–∏–∑–∫–∞—è –∫–æ–Ω–≤–µ—Ä—Å–∏—è –≤ –≥–æ—Ä—è—á–∏–µ –ª–∏–¥—ã. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–ª—É—á—à–∏—Ç—å –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏—é.\"
                )
            
            if escalation_rate < 20:
                recommendations.append(
                    \"–ù–∏–∑–∫–∏–π —É—Ä–æ–≤–µ–Ω—å —ç—Å–∫–∞–ª–∞—Ü–∏–∏. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–ø—É—Å–∫–∞—é—Ç—Å—è –≥–æ—Ç–æ–≤—ã–µ –∫–ª–∏–µ–Ω—Ç—ã.\"
                )
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–æ—Ä–æ–Ω–∫—É
            if funnel.get('s2_goal', 0) < 50:
                recommendations.append(
                    \"–ú–Ω–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–æ–≤ –Ω–µ –¥–æ—Ö–æ–¥—è—Ç –¥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ü–µ–ª–∏. –£–ª—É—á—à–∏—Ç–µ –≤–æ–ø—Ä–æ—Å—ã –æ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—è—Ö.\"
                )
            
            if funnel.get('s5_budget', 0) < 30:
                recommendations.append(
                    \"–ö–ª–∏–µ–Ω—Ç—ã –∏–∑–±–µ–≥–∞—é—Ç –æ–±—Å—É–∂–¥–µ–Ω–∏—è –±—é–¥–∂–µ—Ç–∞. –ü–µ—Ä–µ—Å–º–æ—Ç—Ä–∏—Ç–µ –ø–æ–¥—Ö–æ–¥ –∫ –≤—ã—è—Å–Ω–µ–Ω–∏—é –±—é–¥–∂–µ—Ç–∞.\"
                )
            
            if not recommendations:
                recommendations.append(\"–°–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ. –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥.\")
            
            return recommendations
            
        except Exception as e:
            logger.error(f\"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π: {e}\")
            return [\"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏\"]